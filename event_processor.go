package ldclient

import (
	"bytes"
	"encoding/json"
	"io/ioutil"
	"math/rand"
	"net/http"
	"sync"
	"time"
)

type EventProcessor interface {
	// Sends an event asynchronously.
	SendEvent(Event)
	// Delivers all buffered events now and waits until they have been sent.
	Flush() error
	// Flushes and then shuts down all event processor activity. Subsequent events will be discarded.
	Close()
}

type nullEventProcessor struct{}

type defaultEventProcessor struct {
	eventsIn chan eventInput
	consumer *eventConsumer
}

type eventConsumer struct {
	sdkKey            string
	config            Config
	client            *http.Client
	eventsIn          chan eventInput
	queue             []interface{}
	summarizer        *eventSummarizer
	lastKnownPastTime uint64
	capacityExceeded  bool
	responseCh        chan *http.Response
	closer            chan struct{}
	closeOnce         sync.Once
	disabled          bool
}

type eventPayloadSendTask struct {
	consumer *eventConsumer
	events   []interface{}
	summary  eventSummary
	replyCh  chan error
}

// Payload of the eventsIn channel. If event is nil, this is a flush request. The reply
// channel is non-nil if the caller has requested a reply (for flushes only).
type eventInput struct {
	event Event
	reply chan error
}

// Serializable form of a feature request event. This differs from the event that was
// passed in to us in that it has a user key instead of a user object, and it only shows
// the flag value, not the variation index.
type featureRequestEventOutput struct {
	Kind         string      `json:"kind"`
	CreationDate uint64      `json:"creationDate"`
	Key          string      `json:"key"`
	UserKey      *string     `json:"userKey,omitempty"`
	User         *User       `json:"user,omitempty"`
	Value        interface{} `json:"value"`
	Default      interface{} `json:"default"`
	Version      *int        `json:"version,omitempty"`
	PrereqOf     *string     `json:"prereqOf,omitempty"`
}

// Serializable form of an identify event.
type identifyEventOutput struct {
	Kind         string  `json:"kind"`
	CreationDate uint64  `json:"creationDate"`
	Key          *string `json:"key"`
	User         *User   `json:"user"`
}

// Serializable form of a custom event. It has a user key instead of a user object.
type customEventOutput struct {
	Kind         string      `json:"kind"`
	CreationDate uint64      `json:"creationDate"`
	Key          string      `json:"key"`
	UserKey      *string     `json:"userKey,omitempty"`
	User         *User       `json:"user,omitempty"`
	Data         interface{} `json:"data,omitempty"`
}

// Serializable form of an index event. This is not generated by an explicit client call,
// but is created automatically whenever we see a user we haven't seen before in a feature
// request event or custom event.
type indexEventOutput struct {
	Kind         string `json:"kind"`
	CreationDate uint64 `json:"creationDate"`
	User         *User  `json:"user"`
}

// Serializable form of a summary event, containing data generated by EventSummarizer.
type summaryEventOutput struct {
	Kind      string                     `json:"kind"`
	StartDate uint64                     `json:"startDate"`
	EndDate   uint64                     `json:"endDate"`
	Features  map[string]flagSummaryData `json:"features"`
}

const (
	FEATURE_REQUEST_EVENT = "feature"
	FEATURE_DEBUG_EVENT   = "debug"
	CUSTOM_EVENT          = "custom"
	IDENTIFY_EVENT        = "identify"
	INDEX_EVENT           = "index"
	SUMMARY_EVENT         = "summary"
)

func newNullEventProcessor() *nullEventProcessor {
	return &nullEventProcessor{}
}

func (n *nullEventProcessor) SendEvent(e Event) {
}

func (n *nullEventProcessor) Flush() error {
	return nil
}

func (n *nullEventProcessor) Close() {
}

func newDefaultEventProcessor(sdkKey string, config Config, client *http.Client) *defaultEventProcessor {
	if client == nil {
		client = &http.Client{}
	}
	eventsIn := make(chan eventInput, 100)
	consumer := &eventConsumer{
		sdkKey:     sdkKey,
		config:     config,
		eventsIn:   eventsIn,
		queue:      make([]interface{}, 0),
		client:     client,
		responseCh: make(chan *http.Response),
		closer:     make(chan struct{}),
		summarizer: newEventSummarizer(config),
	}
	res := &defaultEventProcessor{
		eventsIn: eventsIn,
		consumer: consumer,
	}
	consumer.start()
	return res
}

func (ep *defaultEventProcessor) SendEvent(e Event) {
	ep.eventsIn <- eventInput{
		event: e,
		reply: nil,
	}
}

func (ep *defaultEventProcessor) Flush() error {
	input := eventInput{
		event: nil,
		reply: make(chan error),
	}
	ep.eventsIn <- input
	err := <-input.reply
	return err
}

func (ep *defaultEventProcessor) Close() {
	ep.consumer.close()
}

func (ec *eventConsumer) start() {
	go func() {
		if err := recover(); err != nil {
			ec.config.Logger.Printf("Unexpected panic in event processing thread: %+v", err)
		}

		flushInterval := ec.config.FlushInterval
		if flushInterval <= 0 {
			flushInterval = DefaultConfig.FlushInterval
		}
		userKeysFlushInterval := ec.config.UserKeysFlushInterval
		if userKeysFlushInterval <= 0 {
			userKeysFlushInterval = DefaultConfig.UserKeysFlushInterval
		}
		flushTicker := time.NewTicker(flushInterval)
		usersResetTicker := time.NewTicker(userKeysFlushInterval)
		for {
			select {
			case eventIn := <-ec.eventsIn:
				if eventIn.event == nil {
					ec.dispatchFlush(eventIn.reply)
				} else {
					ec.sendEventInternal(eventIn.event)
				}
			case <-flushTicker.C:
				ec.dispatchFlush(nil)
			case <-usersResetTicker.C:
				ec.summarizer.resetUsers()
			case resp := <-ec.responseCh:
				ec.handleResponse(resp)
			case <-ec.closer:
				flushTicker.Stop()
				usersResetTicker.Stop()
				waitCh := make(chan error)
				ec.dispatchFlush(waitCh)
				<-waitCh
				ec.disabled = true
				return
			}
		}
	}()
}

func (ec *eventConsumer) close() {
	ec.closeOnce.Do(func() {
		close(ec.closer)
	})
}

func (ec *eventConsumer) sendEventInternal(evt Event) {
	if ec.disabled {
		return
	}
	// For each user we haven't seen before, we add an index event - unless this is already
	// an identify event for that user.
	if !ec.config.InlineUsersInEvents {
		user := evt.GetBase().User
		if !ec.summarizer.noticeUser(&user) {
			if _, ok := evt.(IdentifyEvent); !ok {
				indexEvent := indexEventOutput{
					Kind:         INDEX_EVENT,
					CreationDate: evt.GetBase().CreationDate,
					User:         &user,
				}
				ec.queueEvent(indexEvent)
			}
		}
	}

	// Always record the event in the summarizer.
	ec.summarizer.summarizeEvent(evt)

	if ec.shouldTrackFullEvent(evt) {
		// Sampling interval applies only to fully-tracked events.
		if ec.config.SamplingInterval == 0 || rand.Int31n(ec.config.SamplingInterval) == 0 {
			// Queue the event as-is; we'll transform it into an output event when we're flushing
			// (to avoid doing that work on our main goroutine).
			ec.queueEvent(evt)
		}
	}
}

func (ec *eventConsumer) shouldTrackFullEvent(evt Event) bool {
	switch evt := evt.(type) {
	case FeatureRequestEvent:
		if evt.TrackEvents {
			return true
		}
		if evt.DebugEventsUntilDate != nil {
			// The "last known past time" comes from the last HTTP response we got from the server.
			// In case the client's time is set wrong, at least we know that any expiration date
			// earlier than that point is definitely in the past.  If there's any discrepancy, we
			// want to err on the side of cutting off event debugging sooner.
			if *evt.DebugEventsUntilDate > ec.lastKnownPastTime &&
				*evt.DebugEventsUntilDate > now() {
				return true
			}
		}
		return false
	default:
		// Custom and identify events are always included in full
		return true
	}
}

func (ec *eventConsumer) queueEvent(event interface{}) {
	if len(ec.queue) >= ec.config.Capacity {
		if !ec.capacityExceeded {
			ec.capacityExceeded = true
			ec.config.Logger.Printf("WARN: Exceeded event queue capacity. Increase capacity to avoid dropping events.")
		}
	} else {
		ec.capacityExceeded = false
		ec.queue = append(ec.queue, event)
	}
}

// Marks the given timestamp (received from the server) as being in the past, in case the
// client-side time is unreliable.
func (ec *eventConsumer) setLastKnownPastTime(t uint64) {
	if ec.lastKnownPastTime < t {
		ec.lastKnownPastTime = t
	}
}

func (ec *eventConsumer) dispatchFlush(replyCh chan error) {
	if ec.disabled {
		return
	}
	events := ec.queue
	summary := ec.summarizer.snapshot()
	ec.queue = make([]interface{}, 0)

	if len(events) == 0 && len(summary.counters) == 0 {
		if replyCh != nil {
			replyCh <- nil
		}
	} else {
		task := eventPayloadSendTask{
			consumer: ec,
			events:   events,
			summary:  summary,
			replyCh:  replyCh,
		}
		task.start()
	}
}

func (ec *eventConsumer) handleResponse(resp *http.Response) {
	err := checkStatusCode(resp.StatusCode, resp.Request.URL.String())
	if err != nil {
		ec.config.Logger.Printf("Unexpected status code when sending events: %+v", err)
		if err != nil && err.Code == 401 {
			ec.config.Logger.Printf("Received 401 error, no further events will be posted since SDK key is invalid")
			ec.disabled = true
		}
	} else {
		dt, err := http.ParseTime(resp.Header.Get("Date"))
		if err == nil {
			tm := toUnixMillis(dt)
			if tm > ec.lastKnownPastTime {
				ec.lastKnownPastTime = tm
			}
		}
	}
}

func (t *eventPayloadSendTask) start() {
	go func() {
		err := t.flushInternal()
		if t.replyCh != nil {
			t.replyCh <- err
		}
	}()
}

func (t *eventPayloadSendTask) flushInternal() error {
	outputEvents := make([]interface{}, 0, len(t.events)+1) // leave room for summary, if any
	userFilter := newUserFilter(t.consumer.config)
	for _, e := range t.events {
		oe := t.makeOutputEvent(e, &userFilter)
		if oe != nil {
			outputEvents = append(outputEvents, oe)
		}
	}
	if len(t.summary.counters) > 0 {
		outputEvents = append(outputEvents, t.makeSummaryEvent(t.summary))
	}

	payload, marshalErr := json.Marshal(outputEvents)

	if marshalErr != nil {
		t.consumer.config.Logger.Printf("Unexpected error marshalling event json: %+v", marshalErr)
		return marshalErr
	}

	eventsUri := t.consumer.config.EventsUri + "/bulk"
	req, reqErr := http.NewRequest("POST", eventsUri, bytes.NewReader(payload))

	if reqErr != nil {
		t.consumer.config.Logger.Printf("Unexpected error while creating event request: %+v", reqErr)
		return reqErr
	}

	req.Header.Add("Authorization", t.consumer.sdkKey)
	req.Header.Add("Content-Type", "application/json")
	req.Header.Add("User-Agent", "GoClient/"+Version)

	resp, respErr := t.consumer.client.Do(req)

	defer func() {
		if resp != nil && resp.Body != nil {
			ioutil.ReadAll(resp.Body)
			resp.Body.Close()
		}
	}()

	if respErr != nil {
		t.consumer.config.Logger.Printf("Unexpected error while sending events: %+v", respErr)
		return respErr
	}
	t.consumer.responseCh <- resp
	err := checkStatusCode(resp.StatusCode, eventsUri)
	return err
}

func (t *eventPayloadSendTask) makeOutputEvent(evt interface{}, uf *userFilter) interface{} {
	switch evt := evt.(type) {
	case FeatureRequestEvent:
		fe := featureRequestEventOutput{
			CreationDate: evt.BaseEvent.CreationDate,
			Key:          evt.Key,
			Value:        evt.Value,
			Default:      evt.Default,
			Version:      evt.Version,
			PrereqOf:     evt.PrereqOf,
		}
		if t.consumer.config.InlineUsersInEvents {
			fe.User = uf.scrubUser(evt.User)
		} else {
			fe.UserKey = evt.User.Key
		}
		if !evt.TrackEvents && evt.DebugEventsUntilDate != nil {
			fe.Kind = FEATURE_DEBUG_EVENT
		} else {
			fe.Kind = FEATURE_REQUEST_EVENT
		}
		return fe
	case CustomEvent:
		ce := customEventOutput{
			Kind:         CUSTOM_EVENT,
			CreationDate: evt.BaseEvent.CreationDate,
			Key:          evt.Key,
			Data:         evt.Data,
		}
		if t.consumer.config.InlineUsersInEvents {
			ce.User = uf.scrubUser(evt.User)
		} else {
			ce.UserKey = evt.User.Key
		}
		return ce
	case IdentifyEvent:
		return identifyEventOutput{
			Kind:         IDENTIFY_EVENT,
			CreationDate: evt.BaseEvent.CreationDate,
			Key:          evt.User.Key,
			User:         uf.scrubUser(evt.User),
		}
	case indexEventOutput:
		evt.User = uf.scrubUser(*evt.User)
		return evt
	default:
		t.consumer.config.Logger.Printf("Found unknown event type in output queue: %T", evt)
		return nil
	}
}

// Transforms the summary data into the format used for event sending.
func (t *eventPayloadSendTask) makeSummaryEvent(snapshot eventSummary) summaryEventOutput {
	features := make(map[string]flagSummaryData)
	for key, value := range snapshot.counters {
		var flagData flagSummaryData
		var known bool
		if flagData, known = features[key.key]; !known {
			flagData = flagSummaryData{
				Default:  value.flagDefault,
				Counters: make([]flagCounterData, 0, 2),
			}
		}
		data := flagCounterData{
			Value: value.flagValue,
			Count: value.count,
		}
		if key.version == 0 {
			unknown := true
			data.Unknown = &unknown
		} else {
			version := key.version
			data.Version = &version
		}
		flagData.Counters = append(flagData.Counters, data)
		features[key.key] = flagData
	}

	return summaryEventOutput{
		Kind:      "summary",
		StartDate: snapshot.startDate,
		EndDate:   snapshot.endDate,
		Features:  features,
	}
}
